.. container::
   :name: viewlet-above-content-title

Calculation of Weights for Data with Varying Integration Time
=============================================================

.. container::
   :name: viewlet-below-content-title

.. container:: documentDescription description

   Knowledgebase Article: Calculation of Weights for Data with Varying
   Integration Time

.. container:: section
   :name: viewlet-above-content-body

.. container:: section
   :name: content-core

   .. container::
      :name: parent-fieldname-text

      | **George Moellenbrock**
      | **Original 18 Dec 2018, latest edited version 04 Nov 2019**
      | When the nominal weights are expected to be uniform (because
      | integration time, channel bandwidth, effective Tsys, collecting
        area,
      | etc. are all uniform, or the visibilities are normalized),
        extracting
      | weight information from the apparent statistics of otherwise
        stable
      | visibility measurements is a simple matter of calculating the
        apparent
      | simple variance in the visibility real and imaginary parts over
        a
      | sufficient local sample of values. The real and imaginary part
      | variances should be approximately equal, and the inverse of
        their mean
      | is the correct weight to assign to each of the visibility values
      | within the sample. Here, "stable visibility" means no
        *systematic*
      | variation of amplitude or phase within the local
      | sample. Noise-dominated visibilities are ideal; otherwise,
      | well-calibrated data with no true visibility variation are
      | desirable. These conditions are also needed for the more general
        case
      | described below.
      | When the integration time (aka "exposure") varies within the
        local
      | sample (such as can be generated by averaging of the data
      | post-correlation, where the number of samples per averaging bin
        may
      | vary, especially at the end of scans), we expect the correct
        variance
      | for each visibility to be inversely proportional to the net
      | integration time, and this complicates the calculation. It is
      | necessary to determine a weighted variance per unit inverse
      | integration time, wherein the sample weights for the variance
      | calculation are the per-visibility integration times,
        e\ :math:`_i`. If the only
      | reason the underlying variance differs among samples is the
        variable
      | integration time, then a uniform normalized variance estimate of
        the
      | whole sample may be obtained by scaling the residual data per
        sample
      | by the square root of their (known) integration times. Here,
        residual
      | data means any underlying visibility signal---presumably the
        average
      | of the visibility samples, using nominal (proportional to
        integration
      | time, etc.) weights---has been subtracted. The simple variance
        of this
      | rescaled sample is, in effect, the variance per unit inverse
      | integration time.
      | For visibilities V\ :math:`_i`, with integration times
        e\ :math:`_i`:
      | <var\ :math:`_{norm}`> = Sum (e\ :math:`_i` (V\ :math:`_i` -
        <V>)\ :math:`^2` / N    [1]
      | where <V> = Sum (w\ :math:`_i` V\ :math:`_i`) / Sum
        (w\ :math:`_i`)       [1a]
      | and w\ :math:`_i` are the nominal data weights presumably
        proportional to
      | integration time and other relevant factors. In practice, we
        could
      | probably just use w\ :math:`_i` = e\ :math:`_i` in equation [1a]
        since all of the other
      | relevant factors witin w\ :math:`_i` are assumed constant within
        the
      | sample. Note that the units of <var\ :math:`_{norm}`> are in
        squared visibility
      | amplitude (Jy\ :math:`^2`, presumably) times seconds. Note also
        that <var\ :math:`_{norm}`>
      | is essentially the simple variance of the ensemble
        [sqrt(e\ :math:`_i`).dV\ :math:`_i`]
      | (where dV\ :math:`_i` is (V\ :math:`_i`-<V>)), i.e., of the
        residual visibilities scaled
      | so that their noise is independent of integration time.
      | The normalized weight-per-unit-integration time is thus the
        inverse of
      | <var\ :math:`_{norm}`>:
      | W\ :math:`_{norm}` =
        1/<var\ :math:`_{norm}`>                      [2]
      | and per-datum revised weights may be calculated as:
      | W\ :math:`_i` = W\ :math:`_{norm}` \* e\ :math:`_i` 
                               [3]
      | Another way of arriving at this result is to calculate a
        weighted
      | variance:
      | <var> = Sum (e\ :math:`_i` (V\ :math:`_i` - <V>)\ :math:`^2`) /
        Sum(e\ :math:`_i`)   [4]
      | which corresponds to the (simple) mean exposure time, which is:
      | <e> = Sum(e\ :math:`_i`) / N                         [5]
      | The product of these yields <var\ :math:`_{norm}`>, as above in
        [1]:
      | <var\ :math:`_{norm}`> = <var><e>                      [6]
      | and W\ :math:`_{norm}` may be formed and applied as in [2] and
        [3] above.
      | This calculation should be done for both real and imaginary
        parts of
      | the visibility sample and averaged, or for both parts jointly,
        and [3]
      | used to form the revised weights.
      | NB: In calculating sample variance, it is generally customary to
      | acknowledge the loss of one degree of freedom due to use of the
        mean
      | visibility, <V> in the calculation. Essentially, <V> will have a
      | finite error that tends to bias the resulting variance downward.
        For
      | simple variance calculations, a factor N/(N-1) is applied to the
      | variance calculation to unbias it, and this factor can be
        significant
      | for modest N. Since a non-trivially weighted mean is used in the
        above
      | (otherwise simple, non-weighted) variance calculation (eqn [1]),
        it
      | may be appropriate to consider a more carefully weighted
        calculation
      | for the N/(N-1) factor. The required factor is:
      | D = 1 - ( Sum(w\ :math:`_i`\ ^2) / Sum(w\ :math:`_i`)^2 ) [9]
      | where w\ :math:`_i` are the a priori nominal weights used in
        [1a] above. This
      | factor can be shown to equal (N-1)/N and so should be *divided*
        into
      | the <var\ :math:`_{norm}`> result.
      | However, since the nominal error in the variance (and thus the
      | weights) will be <10% (an accuracy we are unlikely to achieve in
      | general anyway) for N>10, and will be uniform over many sample
        groups
      | in the overall statwt execution, we assume that it is adequate
        to use the
      | simpler N/(N-1) factor, or omit it entirely.

.. container:: section
   :name: viewlet-below-content-body
